#version 460 core

layout(local_size_x=64) in;

struct Particle {
    vec2 position;
    float angleDirection;
    float PADDING;
};

struct Settings {
    int particlesOffset;
    float senseAngle;
    float senseDistance;
    float turnSpeed;
    int particleCount;
    float movementSpeed;
    float trailWeight;
    float maxTrailValue;
    int sensorSize;
    float maxSteerRandomness;
};

layout(binding = 0, std430)buffer Particles{ Particle particles[]; };
layout(r32f, binding = 1) uniform image2DArray texTrail;
layout(binding = 2, std430)buffer SpeciesSettings{Settings settings[]; };

#define MOUSE_INTERACTION int
#define MOUSE_NONE 0
#define MOUSE_ATTRACT 1
#define MOUSE_REPEL 2
#define MOUSE_DRAW 3

#define PI 3.1415
#define TRUE 1
#define FALSE 0

#define ALL_SPECIES_INTERACT -1

uniform int mouseInteractionActive;
uniform MOUSE_INTERACTION mouseInteractionType;
uniform vec2 mousePosition;
uniform float mouseIntDistance;
uniform float mouseIntPower;
uniform int interactedSpeciesId;

uniform float deltaT;
uniform float time;

vec2 rotate(vec2 v, float a) {
    float s = sin(a);
    float c = cos(a);
    mat2 m = mat2(c, -s, s, c);
    return m * v;
}

uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state) {
    return float(state) / 4294967295.0;
}

float sense(Particle particle, float sensorAngle, ivec2 texSize, Settings sSettings) {
    const uint speciesId = gl_GlobalInvocationID.z;
    const float angle = particle.angleDirection + sensorAngle;
    const vec2 sensorDir = vec2(cos(angle), sin(angle));

    const vec2 sensorPos = particle.position + sensorDir * sSettings.senseDistance;
    const ivec2 iSensorPos = ivec2(sensorPos);

    const int halfSensorSize = sSettings.sensorSize / 2;
    const ivec2 texSensorPos = ivec2(min(texSize.x - 1, max(0, iSensorPos.x)), min(texSize.y - 1, max(0, iSensorPos.y)));

    float tmp = 0;
    for (int x = -halfSensorSize; x <= halfSensorSize; ++x) {
        for (int y = -halfSensorSize; y <= halfSensorSize; ++y) {
            tmp += imageLoad(texTrail, ivec3(texSensorPos + ivec2(x, y), speciesId)).r;
        }
    }

    return tmp;
}

vec2 mouseInteractionDelta(Particle particle) {
    const uint speciesId = gl_GlobalInvocationID.z;
    if (mouseInteractionActive == FALSE || mouseInteractionType == MOUSE_NONE || mouseInteractionType == MOUSE_DRAW) { return vec2(0, 0); }
    if (interactedSpeciesId != ALL_SPECIES_INTERACT && interactedSpeciesId != speciesId) { return vec2(0, 0); }
    vec2 dir = mousePosition - particle.position;
    const float dist = length(dir);
    if (dist < mouseIntDistance) {
        dir = normalize(dir);
        const float effect = (1 - dist / mouseIntDistance) * mouseIntPower;

        return (int(mouseInteractionType == MOUSE_ATTRACT) * dir + int(mouseInteractionType == MOUSE_REPEL) * -dir) * effect;
    }
    return vec2(0, 0);
}

void main() {
    const uint speciesId = gl_GlobalInvocationID.z;
    const Settings sSettings = settings[speciesId];
    if (gl_GlobalInvocationID.x >= sSettings.particleCount) { return; }


    Particle particle = particles[sSettings.particlesOffset + gl_GlobalInvocationID.x];
    const vec2 oldPos = particle.position;


    const ivec2 texSize = imageSize(texTrail).xy;
    uint random = hash(uint(oldPos.y * texSize.x + oldPos.x + hash(uint(gl_GlobalInvocationID.x + time * 100000.f))));

    const float angleR = sSettings.senseAngle * (PI / 180);
    const float fwdVal = sense(particle, 0, texSize, sSettings);
    const float leftVal = sense(particle, angleR, texSize, sSettings);
    const float rightVal = sense(particle, -angleR, texSize, sSettings);

    const float rndSteer = 1 - (scaleToRange01(random) / (1 / sSettings.maxSteerRandomness));
    const float turnSpeedR = sSettings.turnSpeed * 2 * PI;

    if (fwdVal > leftVal && fwdVal > rightVal) {
        //
    } else if (fwdVal < leftVal && fwdVal < rightVal) {
        particles[sSettings.particlesOffset + gl_GlobalInvocationID.x].angleDirection += (rndSteer - 0.5) * 2 * turnSpeedR * deltaT;
    } else if (rightVal > leftVal) {
        particles[sSettings.particlesOffset + gl_GlobalInvocationID.x].angleDirection -= rndSteer * turnSpeedR * deltaT;
    } else if (leftVal > rightVal) {
        particles[sSettings.particlesOffset + gl_GlobalInvocationID.x].angleDirection += rndSteer * turnSpeedR * deltaT;
    }

    const vec2 newDir = vec2(cos(particle.angleDirection), sin(particle.angleDirection));
    vec2 newPos = particle.position + newDir * deltaT * sSettings.movementSpeed;

    if (newPos.x < 0 || newPos.x >= texSize.x || newPos.y < 0 || newPos.y >= texSize.y) {
        random = hash(random);
        const float randomAngle = scaleToRange01(random) * 2 * PI;
        newPos.x = min(texSize.x - 1, max(0, newPos.x));
        newPos.y = min(texSize.y - 1, max(0, newPos.y));
        particles[sSettings.particlesOffset + gl_GlobalInvocationID.x].angleDirection = randomAngle;
    } else {
        const ivec2 tCoord = ivec2(newPos);
        const float prevTrail = imageLoad(texTrail, ivec3(tCoord, speciesId)).r;
        imageStore(texTrail, ivec3(tCoord, speciesId), vec4(min(sSettings.maxTrailValue, prevTrail + sSettings.trailWeight * deltaT)));
    }
    const vec2 attractionDelta = mouseInteractionDelta(particle);
    particles[sSettings.particlesOffset + gl_GlobalInvocationID.x].position = newPos + attractionDelta;
}





























